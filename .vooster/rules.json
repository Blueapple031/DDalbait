{
  "rules": [
    {
      "type": "prd",
      "content": "# 제품 요구사항 문서 (PRD)\n\n## 1. 개요\n부산대 및 인근 농구 동호인을 위한 경기 게시·분석·공유 플랫폼. 이 플랫폼은 사용자 모두가 함께 콘텐츠를 만들고, 기록을 남기며, 커뮤니티를 함께 성장시키는 '참여형 농구 앱'을 지향한다. 사용자는 간편하게 경기를 등록·조회하고, 개인·동아리 통계를 확인하며, 모두의 참여로 커지는 농구 커뮤니티를 경험한다.\n\n## 2. 문제 정의\n- 경기 일정·결과·영상이 흩어져 있어 접근 어려움  \n- 개인·팀 통계 산출 어려움 → 동기 부여 부족  \n- 지역 농구 커뮤니티가 산발적 운영 → 성장 한계\n\n## 3. 목표 및 목적\n- 주요 목표: 농구 경기 통합 관리·분석 서비스 제공  \n- 부차 목표  \n  - 동아리 간 경쟁·교류 촉진  \n  - 개인 기록 시각화로 동기 제공  \n  - 지역 농구 문화 확산  \n- 성공 지표  \n  - MAU ≥ 5,000 / 6개월  \n  - 경기 게시 수 월 1,000건  \n  - 평균 세션 시간 ≥ 6분  \n  - 동아리 랭킹 참여율 ≥ 70 %\n\n## 4. 타깃 사용자\n### 1차 사용자\n- 부산대·경남권 20대 대학생, 주 1회 이상 농구하는 동아리원  \n- 니즈: 경기 신청, 내·팀 기록 확인, 커뮤니티 소통\n### 2차 이해관계자\n- 심판, 학교 체육 담당자, 용품 브랜드, 광고주\n\n## 5. 사용자 스토리\n- “농구 동아리 회장으로서, 팀 랭킹을 확인해 다음 상대를 정하고 싶다.”  \n- “선수로서, 내 3점 슈팅률 변화를 그래프로 보고 훈련 방향을 잡고 싶다.”  \n- “심판으로서, 배정된 경기 일정을 앱에서 즉시 확인하고 싶다.”  \n- “스폰서로서, 인기 경기·팀에 광고를 노출해 브랜드 인지도를 올리고 싶다.”\n\n## 6. 기능 요구사항\n### 핵심 기능\n\n#### 동아리 랭킹전 매칭 플로우\n1. 각 동아리 대표가 경기 날짜를 잡는다.\n2. 심판진에서 심판이 배정된다.\n3. 랭킹전 경기가 성립된다.\n4. 당일 게임을 진행한다.(심판들은 경기를 진행, 기록하고 결과를 등록함)\n5. 등록된 결과는 각 동아리 대표의 확인을 받고 난 후 게시된다.\n- 등록된 결과는 랭킹에 영향을 주며, 경기 세부 내용(3점 성공률, 득점수, 리바운드, 턴오버, 스틸 등)은 선수의 커리어 및 칭호 부여에 반영된다.\n- AC: 모든 필수 필드 입력 시만 게시; 랭킹전은 다음 플로우에 따라 시스템 자동 점수 반영 및 결과 확정:\n  1) 심판 배정 및 기록 등록\n  2) 각 동아리 대표 확인\n  3) 결과 게시 후 랭킹 및 선수 기록 자동 반영\n\n1. 경기 게시  \n   - 입력: 날짜, 장소(GPS), 상대팀, 룰, 영상 URL  \n   - 수락 워크플로우(친선/랭킹전)  \n   - 수락 시 알림 푸시  \n   - 수락/취소 이력 로그  \n   - AC: 모든 필수 필드 입력 시만 게시; 랭킹전은 시스템 자동 점수 반영\n2. 기록·통계  \n- 개인: 득점, 리바운드, 3P%, PER 등 자동 집계(심판진 기록지 기반)  \n- 팀: 승·패·득실점·랭킹(심판진 기록지 기반)  \n   - 시각화: 차트, 히트맵  \n   - AC: 경기 종료 후 10분 내 통계 반영\n3. 랭킹 및 리더보드  \n   - 동아리·개인 탑 100  \n   - 필터: 기간, 지역, 경기 종류  \n   - AC: 정렬·검색 1초 이하\n4. 일정/매칭  \n   - 랭킹전·친선전 구분  \n   - 자동 매칭 제안(실력·거리 기준)  \n   - 캘린더 동기화(구글·iCal)  \n5. 콘텐츠 공유  \n   - 사진·영상 업로드, 하이라이트 자동 클립 생성(Beta)  \n   - SNS 연동(Instagram, KakaoTalk)  \n   - 공개/비공개 설정\n### 지원 기능\n- 역할 기반 계정(운영, 일반, 심판)  \n- 심판진 전용 기록지 작성 및 제출 기능(경기 중 실시간 득점, 파울 등 입력)\n- 포인트 상점(스킨, 굿즈, 쿠폰)  \n- 알림 센터(경기 요청, 결과, 랭킹 변동)  \n- 관리자 대시보드(신고, 통계, 광고 관리)\n\n## 7. 비기능 요구사항\n- 성능: 주요 API 응답 ≤ 300 ms, 동시 접속 10k  \n- 보안: OAuth 2.0, JWT, HTTPS, DB 암호화(AES-256)  \n- 사용성: iOS/Android/Web 반응형, 접근성 WCAG 2.1 AA  \n- 확장성: 모듈화 마이크로서비스, 멀티 리전  \n- 호환: iOS 14+, Android 9+, Chrome/Safari 최신\n\n## 8. 기술 고려\n- 프론트: React Native + Expo, Next.js(Web)  \n- 백엔드: Node.js(NestJS), PostgreSQL, Redis, GraphQL  \n- 데이터: AWS RDS, S3(미디어), Athena(분석), Python ETL  \n- 인프라: AWS EKS, CloudFront, WAF, CI/CD(GitHub Actions)  \n- 외부 연동: Stripe 결제, Firebase Push, SNS API  \n- 영상 분석: OpenCV, FFmpeg(하이라이트), 추후 ML 모델 연계\n\n## 9. 성공 지표\n- 사용자: 일일 경기 등록 ≥ 50, 개인 통계 조회율 ≥ 60 %  \n- 비즈니스: 광고 클릭률 ≥ 2 %, 포인트 상점 월 매출 ≥ 3 M KRW  \n- 기술: 오류율 < 1 %, 평균 로딩 < 2 s\n\n## 10. 일정·마일스톤\n- Phase 1 (M0~M3): MVP – 경기 게시·통계·랭킹, iOS/Android/Web 기본  \n- Phase 2 (M4~M6): 자동 매칭, SNS 공유, 심판 모드, 광고 베타  \n- Phase 3 (M7~M9): 포인트 상점, 하이라이트 생성, ML 통계 고도화  \n- 런칭: M6 부산대 테스트 → M9 전국 대학 확장\n\n## 11. 위험 및 대응\n- 데이터 정확성: 수기 입력 오류 → 경기 후 심판 확인 플로우  \n- 사용자 확보: 초기 콘텐츠 부족 → 런칭 전 토너먼트 개최·영상 제공  \n- 기술: 동시 접속 폭증 → 오토스케일링, 캐싱  \n- 법적: 개인정보·영상 저작권 → 사용자 동의, 신고·삭제 체계\n\n## 12. 향후 과제\n- AI 기반 플레이 분석 및 개인 맞춤 훈련 피드백\n- 글로벌 버전(다국어 UI) 및 e스포츠화\n\n\n",
      "writedAt": "2025-07-18T10:23:32.988Z"
    },
    {
      "type": "architecture",
      "content": "# Technical Requirements Document (TRD)\n\n## 1. Executive Technical Summary\n- **프로젝트 개요**  \n  - 부산대 및 인근 농구 동호인을 위한 경기 등록·통계·커뮤니티 플랫폼을 2개월 내 MVP로 출시  \n  - 모바일(React Native + Expo)·웹(Next.js) 단일 코드베이스를 사용해 개발 속도 극대화  \n  - 백엔드는 NestJS + GraphQL API로 통합 제공, PostgreSQL·Redis를 활용해 단순·견고한 구조 유지\n- **핵심 기술 스택**  \n  - Frontend: React Native 0.73, Expo SDK 50, Next.js 14  \n  - Backend: Node.js 20, NestJS 10, GraphQL (server @nestjs/graphql)  \n  - Database: PostgreSQL 15, Redis 7  \n  - Infra: AWS Fargate(ECS) + RDS (PostgreSQL) + S3 + CloudFront  \n- **주요 기술 목표**  \n  - API 평균 응답 ≤ 300 ms, 동시 접속 10k 유지  \n  - 배포 자동화, 장애 시 무중단 롤백  \n  - 개인정보·결제정보 AES-256 at rest / TLS 1.2 in transit  \n- **중요 기술 가정**  \n  - 초기 트래픽은 부산대 지역 사용자 중심으로 일일 2k DAU 예상  \n  - 영상은 외부 URL 중심(YouTube, Navertv)으로 저장 용량 최소화  \n  - 2개월 MVP 기간 동안 머신러닝 기능은 보류, 단순 통계 계산만 구현\n\n## 2. Technology Stack Architecture\n### Frontend Technology Stack\n- **Core Framework**: React Native 0.73 (Expo Managed Workflow) / Next.js 14 (App Router)  \n- **State Management**: React Query + Context API; 글로벌 캐싱은 React Query만 사용해 단순화  \n- **Routing & Navigation**: Expo Router(모바일) / Next.js App Router(웹)  \n- **UI/UX Framework**: Tamagui(크로스 플랫폼 컴포넌트) + Tailwind-in-JS(tamagui-twind)  \n- **Build Tools**: Expo CLI·Bun(로컬) / Vite + SWC(웹 빌드)  \n\n### Backend Technology Stack\n- **Runtime Environment**: Node.js 20(LTS) + TypeScript 5  \n- **Web Framework**: NestJS 10(GraphQL Code-First)  \n- **API Design Pattern**: GraphQL HTTP endpoint 단일; 파일 업로드는 REST endpoint 분리  \n- **Data Validation**: class-validator / Zod 섞어 사용, DTO 레이어에 적용  \n- **Middleware Components**:  \n  - 보안: helmet, rate-limit-redis  \n  - 로깅: pino, pino-http  \n  - 모니터링: OpenTelemetry collector  \n\n### Database & Persistence Layer\n- **Primary Database**: PostgreSQL 15(RDS Multi-AZ) – 관계형 데이터·조인 및 트랜잭션 신뢰성 확보  \n- **Schema Design**: 정규화 3NF, JSONB(추가 메타) 혼용; TypeORM/Prisma 대신 MikroORM로 경량화  \n- **Caching Strategy**: Redis 7(ElastiCache) – 세션, 랭킹 조회, GraphQL persisted query 캐시  \n- **Data Migration**: MikroORM migrator + Git 버전 관리; 환경별 자동 적용  \n- **Backup & Recovery**: RDS 자동 스냅샷(일 1회, 7일 보존) + S3 Export; Redis AOF 백업은 주 1회  \n\n### Infrastructure & DevOps\n- **Hosting Environment**: AWS – ECS Fargate(무관리 컨테이너), ALB, WAF  \n- **Containerization**: Dockerfile 멀티스테이지; ARM64 이미지로 비용 절감  \n- **CI/CD Pipeline**: GitHub Actions – PR 단위 테스트, 이미지 빌드, ECR 푸시, ECS 자동 배포  \n- **Monitoring & Observability**: AWS CloudWatch Logs, X-Ray, Grafana Cloud(오픈소스 플랜)  \n- **Logging Strategy**: pino-pretty(개발) / pino-elastic(운영) → Elasticsearch-compatible 저장소  \n\n## 3. System Architecture Design\n### Top-Level Building Blocks\n- 프론트엔드 앱(React Native / Next.js)  \n  - 공통 컴포넌트, GraphQL client, 알림 처리  \n- API Gateway(ALB + NestJS)  \n  - 인증·권한, GraphQL Resolver, REST 파일 업로드  \n- 데이터 계층(PostgreSQL + Redis)  \n  - 관계형 데이터 저장, 캐싱·세션·랭킹  \n- 미디어 서비스(S3)  \n  - 이미지·영상 썸네일 저장, CloudFront CDN 배포  \n- DevOps 파이프라인(GitHub Actions + ECR + Fargate)  \n  - 빌드, 테스트, 배포 자동화  \n\n### Top-Level Component Interaction Diagram\n```mermaid\ngraph TD\n    FE[React Native / Next.js] --> GW[API Gateway (NestJS)]\n    GW --> DB[PostgreSQL]\n    GW --> RS[Redis]\n    FE --> S3[(S3 / CloudFront)]\n    GW --> S3\n```\n- 사용자는 모바일·웹 클라이언트(FE)에서 GraphQL 요청을 발행  \n- API Gateway는 인증을 검증한 뒤 PostgreSQL·Redis에 접근  \n- 랭킹·세션 정보는 Redis 캐시를 우선 조회, 없는 경우 PostgreSQL 쿼리  \n- 이미지·영상 업로드는 클라이언트에서 S3 Pre-Signed URL 사용, CDN 통해 배포  \n\n### Code Organization & Convention\n**Domain-Driven Organization Strategy**\n- 도메인 기준: match, club, player, ranking, auth, payment, media  \n- 레이어: controller(resolver) → service → repository → entity  \n- 기능 모듈별 단일 책임; 공유 유틸은 common 모듈로 분리  \n- 프론트는 feature 폴더 방식; hooks, ui, api 등 재사용성 고려  \n\n**Universal File & Folder Structure**\n```\n/hoops-platform\n├── apps/\n│   ├── mobile/          # React Native + Expo\n│   └── web/             # Next.js\n├── packages/\n│   ├── ui/              # Tamagui shared components\n│   ├── graphql-client/  # Apollo setup\n│   └── config/          # ESLint, tsconfig base\n├── services/\n│   └── api/\n│       ├── src/\n│       │   ├── modules/\n│       │   │   ├── auth/\n│       │   │   ├── club/\n│       │   │   ├── match/\n│       │   │   ├── player/\n│       │   │   ├── ranking/\n│       │   │   └── media/\n│       │   ├── common/\n│       │   ├── main.ts\n│       │   └── app.module.ts\n│       └── Dockerfile\n├── infrastructure/\n│   ├── terraform/       # RDS, ECS, S3, CloudFront\n│   └── github-actions/  # CI/CD workflows\n└── docs/\n    └── architecture.md\n```\n\n### Data Flow & Communication Patterns\n- **Client-Server Communication**: Apollo Client → GraphQL over HTTPS; 에러는 GraphQL error extension에 코드 포함  \n- **Database Interaction**: MikroORM Unit-of-Work 패턴, 트랜잭션 단위는 요청별 Context  \n- **External Service Integration**: Firebase Cloud Messaging, OAuth2(SNS 로그인), Stripe Webhook REST endpoint  \n- **Real-time Communication**: 랭킹 변동 알림은 FCM 푸시; WebSocket 미도입(단순 푸시로 충분)  \n- **Data Synchronization**: Redis pub/sub로 랭킹 업데이트 브로드캐스트, DB와 주기적 5초 간격 동기화  \n\n## 4. Performance & Optimization Strategy\n- 쿼리 최적화: 인덱스 설계(경기 날짜, 팀 ID 복합), EXPLAIN 분석 후 300 ms 기준 검증  \n- GraphQL persisted query + CDN edge cache를 활용해 공통 조회 Latency 감소  \n- 이미지 리사이즈 Lambda@Edge로 실행, FE에는 WebP 만 전달해 데이터 전송량 30 % 절감  \n- AWS Fargate 오토스케일: CPU 70 % 이상 시 2분 내 컨테이너 수평 확장  \n\n## 5. Implementation Roadmap & Milestones\n### Phase 1: Foundation (MVP Implementation) – M0~M2\n- Core Infrastructure: VPC, RDS, ECS, S3, CI/CD 구축  \n- Essential Features: 경기 게시, 결과 입력, 기본 통계, 랭킹 리스트  \n- Basic Security: JWT OAuth, HTTPS, WAF 기본 룰  \n- Development Setup: 모노레포, ESLint/Prettier, Husky pre-commit  \n- Timeline: 8주  \n\n### Phase 2: Feature Enhancement – M2~M4\n- Advanced Features: 심판 모드, 캘린더 동기화, SNS 공유, 푸시 알림  \n- Performance Optimization: 캐싱 레이어, 이미지 CDN, 인덱스 튜닝  \n- Enhanced Security: 2FA 선택, DB 암호화 컬럼 수준 확대  \n- Monitoring Implementation: Grafana 대시보드, Alertmanager  \n- Timeline: 8주  \n\n### Phase 3: Scaling & Optimization – M4~M6\n- Scalability Implementation: 멀티 AZ / Read Replica, Redis Cluster  \n- Advanced Integrations: Stripe 결제, 광고 모듈, 포인트 상점  \n- Enterprise Features: 관리자 대시보드, 신고·제재 워크플로우  \n- Compliance & Auditing: 로그 불변 스토리지(S3 Object Lock), 개인정보 파기 정책  \n- Timeline: 8주  \n\n## 6. Risk Assessment & Mitigation Strategies\n### Technical Risk Analysis\n- **기술 선택 위험**: GraphQL 과다 복잡성 → Code-First 스키마, 모놀리식 API 유지  \n- **성능 위험**: 랭킹 집계 병목 → Redis Sorted Set, 비동기 집계 워커  \n- **보안 위험**: JWT 탈취 → short-lived token(15 min) + Refresh Token Rotation  \n- **통합 위험**: 외부 OAuth 장애 → 로컬 이메일 로그인 대안 유지  \n- **대응 전략**: SLO 정의, 캐패시티 테스트, 보안 Pen-Test 사전 실행  \n\n### Project Delivery Risks\n- **일정 위험**: 2개월 MVP 달성 실패 가능 → 스코프 엄격 관리, Nice-to-Have 기능 뒤로 이동  \n- **자원 위험**: 풀스택 인력 부족 → 모노레포로 코드 재사용 극대화, 업무 교차 가능  \n- **품질 위험**: 테스트 커버리지 저하 → Vitest(unit) + Playwright(e2e) 목표 60 % 이상  \n- **배포 위험**: 잘못된 이미지 배포 → GitHub Actions Canary 배포 단계, 1회 트래픽 10 %  \n- **우회 계획**: 기능 토글, 롤백 스크립트, 데이터 백업 사전 검증  \n\n",
      "writedAt": "2025-07-18T10:23:32.993Z"
    },
    {
      "type": "guideline",
      "content": "# Code Guideline for Hoops Platform\n\n## 1. Project Overview\nThe Hoops Platform is a monorepo-based, cross-platform basketball match management system.  \n- **Frontend**: React Native 0.73 (Expo SDK 50) for mobile, Next.js 14 (App Router) for web. Shared UI components in `packages/ui`.  \n- **Backend**: NestJS 10 with GraphQL Code‐First on Node.js 20 + TypeScript 5. MikroORM manages PostgreSQL 15, Redis 7 for caching/session.  \n- **Infra & DevOps**: AWS ECS Fargate, RDS Multi-AZ, S3/CloudFront, GitHub Actions CI/CD, auto-scaling, WAF, TLS 1.2, AES-256 at rest.  \n- **Key Decisions**:  \n  - Monorepo packaging with Yarn Workspaces.  \n  - Domain-driven module boundaries in `/services/api/src/modules`.  \n  - GraphQL for core API; REST for file uploads.  \n  - React Query + Context API for state/data; no Redux.  \n\n---\n\n## 2. Core Principles\n1. **Single Responsibility**: Each file/module serves one purpose; measurable by “one class or one hook per file.”  \n2. **Type Safety**: Enforce `strict` TypeScript settings; zero `any`; validate DTOs with class-validator/Zod.  \n3. **Consistent Error Handling**: All async flows must use try/catch + NestJS Exception Filters or React Error Boundaries.  \n4. **Domain Modularity**: Code organized by feature/domain; enforce `/modules/{domain}` structure.  \n5. **Performance-First**: API responses ≤300 ms; use caching, pagination, indexing; measure with automated benchmarks.\n\n---\n\n## 3. Language-Specific Guidelines\n\n### 3.1 TypeScript (Front & Back)\n- **Directory Structure**  \n  ```\n  /hoops-platform\n  ├── apps/\n  │   ├── mobile/      # React Native\n  │   └── web/         # Next.js\n  ├── packages/\n  │   ├── ui/          # Tamagui components\n  │   ├── graphql-client/\n  │   └── config/      # ESLint, tsconfig.base.json\n  └── services/\n      └── api/\n          └── src/\n              ├── modules/\n              ├── common/\n              ├── main.ts\n              └── app.module.ts\n  ```\n- **Imports & Paths**  \n  - Use absolute imports via `tsconfig.json` paths (`@modules`, `@common`, `@ui`).  \n  - Avoid deep relative imports (`../../../`).  \n- **Dependency Management**  \n  - Centralize shared deps in root `package.json`.  \n  - Pin versions; run `yarn workspace foreach yarn lint` on CI.  \n\n### 3.2 React Native & Next.js\n- **File Organization**  \n  - Feature folder per screen:  \n    ```\n    apps/mobile/src/features/MatchList/\n      ├── MatchList.tsx\n      ├── useMatchList.ts\n      └── styles.ts\n    ```\n  - Shared UI in `packages/ui`.  \n- **Error Handling**  \n  - Wrap top‐level in `<ErrorBoundary>`; log to Sentry/CloudWatch.  \n  - Use Suspense + React Query error states.\n\n### 3.3 NestJS & GraphQL\n- **Module Structure**  \n  ```\n  modules/\n    match/\n      ├── dto/\n      ├── entities/\n      ├── match.resolver.ts\n      ├── match.service.ts\n      └── match.module.ts\n  ```\n- **Validation & Serialization**  \n  - Use `class-validator` on DTOs.  \n  - Enable `autoTransform` in `ValidationPipe`.  \n- **Error Handling**  \n  - Throw `new BadRequestException()` for client errors.  \n  - Use a global `HttpExceptionFilter`.\n\n---\n\n## 4. Code Style Rules\n\n### MUST Follow\n1. **ESLint & Prettier**  \n   - Rule: `extends: ['@hoops/eslint-config', 'prettier']`  \n   - Rationale: Enforces consistent style.  \n2. **Type Annotations for Exports**  \n   ```ts\n   export interface User { id: string; name: string }\n   export const getUser = async (): Promise<User> => { /* ... */ }\n   ```\n   - Rationale: Clarity on public API shapes.  \n3. **GraphQL Naming**  \n   - Types: PascalCase (`MatchResult`).  \n   - Queries: `getMatchById`, Mutations: `createMatch`.  \n4. **Async/Await Only**  \n   ```ts\n   // MUST\n   try {\n     const stats = await this.matchService.computeStats();\n   } catch (error) {\n     throw new InternalServerErrorException();\n   }\n   ```\n   - Rationale: Avoid callback hell; consistent error capture.  \n5. **DTO + Validation Pipe**  \n   ```ts\n   @InputType()\n   export class CreateMatchDto {\n     @Field() @IsDateString() date: string;\n     @Field() @IsString() location: string;\n   }\n   ```\n   - Rationale: Guarantees payload correctness.\n\n### MUST NOT Do\n1. **No `any`**  \n   ```ts\n   // MUST NOT\n   const data: any = await fetchData();\n   ```\n   - Replace with precise types.  \n2. **No Large Multi-Responsibility Files**  \n   - Modules >300 LOC must be split.  \n3. **No Inline Network Logic in UI**  \n   - Always use React Query hooks in `use*` files.  \n4. **No Console Logs in Production**  \n   - Use `pino` with log levels; disable `console.log`.  \n5. **No Direct DB Queries in Services**  \n   - Must go through repository/ORM layer.\n\n---\n\n## 5. Architecture Patterns\n\n### 5.1 Module Structure (Backend)\n- **Controller/Resolver → Service → Repository → Entity**  \n- Shared utilities in `common/`, guards/interceptors/filters in `common/`.\n\n### 5.2 Data Flow\n1. Client sends GraphQL request.  \n2. Global Auth Guard validates JWT.  \n3. Resolver delegates to Service.  \n4. Service calls Repository (MikroORM), uses Redis cache if configured.  \n5. Service returns DTO; GraphQL serializes response.\n\n### 5.3 State Management (Frontend)\n- **React Query** for data fetching/caching:  \n  ```ts\n  export const useMatchList = () =>\n    useQuery(['matches'], fetchMatches, { staleTime: 10000 });\n  ```\n- Global state via Context API only for UI theme, auth tokens.\n\n### 5.4 API Design Standards\n- GraphQL Code-First with class decorators.  \n- Queries for reads, Mutations for writes.  \n- Consistent Error Types: `BadRequestException`, `UnauthorizedException`, `NotFoundException`.  \n- File uploads via REST `/upload` endpoint with pre-signed S3 URLs.\n\n---\n\n## 6. Example Code Snippets\n\n```ts\n// MUST: Module folder structure\n// match.module.ts\nimport { Module } from '@nestjs/common';\nimport { MatchResolver } from './match.resolver';\nimport { MatchService } from './match.service';\nimport { MatchRepository } from './match.repository';\n\n@Module({\n  providers: [MatchResolver, MatchService, MatchRepository],\n})\nexport class MatchModule {}\n```\n\n```ts\n// MUST: GraphQL Resolver with proper error handling\n@Resolver(() => Match)\nexport class MatchResolver {\n  constructor(private readonly matchService: MatchService) {}\n\n  @Query(() => Match)\n  async getMatchById(@Args('id', { type: () => ID }) id: string) {\n    const match = await this.matchService.findById(id);\n    if (!match) throw new NotFoundException('Match not found');\n    return match;\n  }\n}\n```\n\n```ts\n// MUST NOT: Mixing DB logic and HTTP in controller\n@Controller('match')\nexport class MatchController {\n  @Get()\n  async allMatches() {\n    // ❌ Direct SQL in controller violates SRP and reuse\n    return this.connection.query('SELECT * FROM match');\n  }\n}\n```\n\n```tsx\n// MUST: React Query hook in feature folder\nimport { useQuery } from '@tanstack/react-query';\nimport { fetchMatches } from '../api/matchApi';\n\nexport function useMatchList() {\n  return useQuery(['matches'], fetchMatches, {\n    staleTime: 60000,\n    onError: (err) => console.error(err),\n  });\n}\n```\n\n```tsx\n// MUST NOT: Inline fetch in component\nexport function MatchList() {\n  const [matches, setMatches] = useState([]);\n  useEffect(() => {\n    // ❌ Violates data-layer separation\n    fetch('/graphql', { /* ... */ })\n      .then(r => r.json())\n      .then(data => setMatches(data.matches));\n  }, []);\n  return <View>{/* ... */}</View>;\n}\n```\n\n---\n\n## 7. Enforcement & Tooling\n- **CI**: On every PR, run `yarn lint`, `yarn test`, `yarn build`.  \n- **Pre-commit**: Husky + lint-staged for formatting.  \n- **Monitoring**: Track code coverage (Vitest ≥60%, Playwright ≥60%).  \n\nAll guidelines above constitute the single source of truth. Adhering ensures maintainable, scalable, and high-quality code across Hoops Platform.",
      "writedAt": "2025-07-18T10:23:32.993Z"
    },
    {
      "type": "step-by-step",
      "content": "\n## Core Directive\nYou are a senior software engineer AI assistant. For EVERY task request, you MUST follow the three-phase process below in exact order. Each phase must be completed with expert-level precision and detail.\n\n## Guiding Principles\n- **Minimalistic Approach**: Implement high-quality, clean solutions while avoiding unnecessary complexity\n- **Expert-Level Standards**: Every output must meet professional software engineering standards\n- **Concrete Results**: Provide specific, actionable details at each step\n\n---\n\n## Phase 1: Codebase Exploration & Analysis\n**REQUIRED ACTIONS:**\n1. **Systematic File Discovery**\n   - List ALL potentially relevant files, directories, and modules\n   - Search for related keywords, functions, classes, and patterns\n   - Examine each identified file thoroughly\n\n2. **Convention & Style Analysis**\n   - Document coding conventions (naming, formatting, architecture patterns)\n   - Identify existing code style guidelines\n   - Note framework/library usage patterns\n   - Catalog error handling approaches\n\n**OUTPUT FORMAT:**\n```\n### Codebase Analysis Results\n**Relevant Files Found:**\n- [file_path]: [brief description of relevance]\n\n**Code Conventions Identified:**\n- Naming: [convention details]\n- Architecture: [pattern details]\n- Styling: [format details]\n\n**Key Dependencies & Patterns:**\n- [library/framework]: [usage pattern]\n```\n\n---\n\n## Phase 2: Implementation Planning\n**REQUIRED ACTIONS:**\nBased on Phase 1 findings, create a detailed implementation roadmap.\n\n**OUTPUT FORMAT:**\n```markdown\n## Implementation Plan\n\n### Module: [Module Name]\n**Summary:** [1-2 sentence description of what needs to be implemented]\n\n**Tasks:**\n- [ ] [Specific implementation task]\n- [ ] [Specific implementation task]\n\n**Acceptance Criteria:**\n- [ ] [Measurable success criterion]\n- [ ] [Measurable success criterion]\n- [ ] [Performance/quality requirement]\n\n### Module: [Next Module Name]\n[Repeat structure above]\n```\n\n---\n\n## Phase 3: Implementation Execution\n**REQUIRED ACTIONS:**\n1. Implement each module following the plan from Phase 2\n2. Verify ALL acceptance criteria are met before proceeding\n3. Ensure code adheres to conventions identified in Phase 1\n\n**QUALITY GATES:**\n- [ ] All acceptance criteria validated\n- [ ] Code follows established conventions\n- [ ] Minimalistic approach maintained\n- [ ] Expert-level implementation standards met\n\n---\n\n## Success Validation\nBefore completing any task, confirm:\n- ✅ All three phases completed sequentially\n- ✅ Each phase output meets specified format requirements\n- ✅ Implementation satisfies all acceptance criteria\n- ✅ Code quality meets professional standards\n\n## Response Structure\nAlways structure your response as:\n1. **Phase 1 Results**: [Codebase analysis findings]\n2. **Phase 2 Plan**: [Implementation roadmap]  \n3. **Phase 3 Implementation**: [Actual code with validation]\n",
      "writedAt": "2025-07-18T10:23:32.993Z"
    },
    {
      "type": "tdd",
      "content": "\n# TDD Process Guidelines - Cursor Rules\n\n## ⚠️ MANDATORY: Follow these rules for EVERY implementation and modification\n\n**This document defines the REQUIRED process for all code changes. No exceptions without explicit team approval.**\n\n## Core Cycle: Red → Green → Refactor\n\n### 1. RED Phase\n- Write a failing test FIRST\n- Test the simplest scenario\n- Verify test fails for the right reason\n- One test at a time\n\n### 2. GREEN Phase  \n- Write MINIMAL code to pass\n- \"Fake it till you make it\" is OK\n\n- YAGNI principle\n\n### 3. REFACTOR Phase\n- Remove duplication\n- Improve naming\n- Simplify structure\n- Keep tests passing\n\n## Test Quality: FIRST Principles\n- **Fast**: Milliseconds, not seconds\n- **Independent**: No shared state\n- **Repeatable**: Same result every time\n- **Self-validating**: Pass/fail, no manual checks\n- **Timely**: Written just before code\n\n## Test Structure: AAA Pattern\n```\n// Arrange\nSet up test data and dependencies\n\n// Act\nExecute the function/method\n\n// Assert\nVerify expected outcome\n```\n\n## Implementation Flow\n1. **List scenarios** before coding\n2. **Pick one scenario** → Write test\n3. **Run test** → See it fail (Red)\n4. **Implement** → Make it pass (Green)\n5. **Refactor** → Clean up (Still Green)\n6. **Commit** → Small, frequent commits\n7. **Repeat** → Next scenario\n\n## Test Pyramid Strategy\n- **Unit Tests** (70%): Fast, isolated, numerous\n- **Integration Tests** (20%): Module boundaries\n- **Acceptance Tests** (10%): User scenarios\n\n## Outside-In vs Inside-Out\n- **Outside-In**: Start with user-facing test → Mock internals → Implement details\n- **Inside-Out**: Start with core logic → Build outward → Integrate components\n\n## Common Anti-patterns to Avoid\n- Testing implementation details\n- Fragile tests tied to internals  \n- Missing assertions\n- Slow, environment-dependent tests\n- Ignored failing tests\n\n## When Tests Fail\n1. **Identify**: Regression, flaky test, or spec change?\n2. **Isolate**: Narrow down the cause\n3. **Fix**: Code bug or test bug\n4. **Learn**: Add missing test cases\n\n## Team Practices\n- CI/CD integration mandatory\n- No merge without tests\n- Test code = Production code quality\n- Pair programming for complex tests\n- Regular test refactoring\n\n## Pragmatic Exceptions\n- UI/Graphics: Manual + snapshot tests\n- Performance: Benchmark suites\n- Exploratory: Spike then test\n- Legacy: Test on change\n\n## Remember\n- Tests are living documentation\n- Test behavior, not implementation\n- Small steps, fast feedback\n- When in doubt, write a test\n",
      "writedAt": "2025-07-18T10:23:32.993Z"
    },
    {
      "type": "clean-code",
      "content": "\n# Clean Code Guidelines\n\nYou are an expert software engineer focused on writing clean, maintainable code. Follow these principles rigorously:\n\n## Core Principles\n- **DRY** - Eliminate duplication ruthlessly\n- **KISS** - Simplest solution that works\n- **YAGNI** - Build only what's needed now\n- **SOLID** - Apply all five principles consistently\n- **Boy Scout Rule** - Leave code cleaner than found\n\n## Naming Conventions\n- Use **intention-revealing** names\n- Avoid abbreviations except well-known ones (e.g., URL, API)\n- Classes: **nouns**, Methods: **verbs**, Booleans: **is/has/can** prefix\n- Constants: UPPER_SNAKE_CASE\n- No magic numbers - use named constants\n\n## Functions & Methods\n- **Single Responsibility** - one reason to change\n- Maximum 20 lines (prefer under 10)\n- Maximum 3 parameters (use objects for more)\n- No side effects in pure functions\n- Early returns over nested conditions\n\n## Code Structure\n- **Cyclomatic complexity** < 10\n- Maximum nesting depth: 3 levels\n- Organize by feature, not by type\n- Dependencies point inward (Clean Architecture)\n- Interfaces over implementations\n\n## Comments & Documentation\n- Code should be self-documenting\n- Comments explain **why**, not what\n- Update comments with code changes\n- Delete commented-out code immediately\n- Document public APIs thoroughly\n\n## Error Handling\n- Fail fast with clear messages\n- Use exceptions over error codes\n- Handle errors at appropriate levels\n- Never catch generic exceptions\n- Log errors with context\n\n## Testing\n- **TDD** when possible\n- Test behavior, not implementation\n- One assertion per test\n- Descriptive test names: `should_X_when_Y`\n- **AAA pattern**: Arrange, Act, Assert\n- Maintain test coverage > 80%\n\n## Performance & Optimization\n- Profile before optimizing\n- Optimize algorithms before micro-optimizations\n- Cache expensive operations\n- Lazy load when appropriate\n- Avoid premature optimization\n\n## Security\n- Never trust user input\n- Sanitize all inputs\n- Use parameterized queries\n- Follow **principle of least privilege**\n- Keep dependencies updated\n- No secrets in code\n\n## Version Control\n- Atomic commits - one logical change\n- Imperative mood commit messages\n- Reference issue numbers\n- Branch names: `type/description`\n- Rebase feature branches before merging\n\n## Code Reviews\n- Review for correctness first\n- Check edge cases\n- Verify naming clarity\n- Ensure consistent style\n- Suggest improvements constructively\n\n## Refactoring Triggers\n- Duplicate code (Rule of Three)\n- Long methods/classes\n- Feature envy\n- Data clumps\n- Divergent change\n- Shotgun surgery\n\n## Final Checklist\nBefore committing, ensure:\n- [ ] All tests pass\n- [ ] No linting errors\n- [ ] No console logs\n- [ ] No commented code\n- [ ] No TODOs without tickets\n- [ ] Performance acceptable\n- [ ] Security considered\n- [ ] Documentation updated\n\nRemember: **Clean code reads like well-written prose**. Optimize for readability and maintainability over cleverness.\n",
      "writedAt": "2025-07-18T10:23:32.993Z"
    },
    {
      "type": "git-commit-message",
      "content": "\n# Git Commit Message Rules\n\n## Format Structure\n```\n<type>(<scope>): <description>\n\n[optional body]\n\n[optional footer]\n```\n\n## Types (Required)\n- `feat`\n- `fix`\n- `docs`\n- `style`\n- `refactor`\n- `perf`\n- `test`\n- `chore`\n- `ci`\n- `build`\n- `revert`\n\n## Scope (Optional)\n- Component, file, or feature area affected\n- Use kebab-case: `user-auth`, `payment-api`\n- Omit if change affects multiple areas\n\n## Description Rules\n- Use imperative mood\n- No capitalization of first letter\n- No period at end\n- Max 50 characters\n- Be specific and actionable\n\n## Body Guidelines\n- Wrap at 72 characters\n- Explain what and why, not how\n- Separate from description with blank line\n- Use bullet points for multiple changes\n\n## Footer Format\n- `BREAKING CHANGE:` for breaking changes\n- `Closes #123` for issue references\n- `Co-authored-by: Vooster AI (@vooster-ai)`\n\n## Examples\n```\nfeat(auth): add OAuth2 Google login\n\nfix: resolve memory leak in user session cleanup\n\ndocs(api): update authentication endpoints\n\nrefactor(utils): extract validation helpers to separate module\n\nBREAKING CHANGE: remove deprecated getUserData() method\n```\n\n## Workflow Integration\n**ALWAYS write a commit message after completing any development task, feature, or bug fix.**\n\n## Validation Checklist\n- [ ] Type is from approved list\n- [ ] Description under 50 chars\n- [ ] Imperative mood used\n- [ ] No trailing period\n- [ ] Meaningful and clear context\n    ",
      "writedAt": "2025-07-18T10:23:32.993Z"
    }
  ]
}